import ctypes
import importlib.util
from typing import List, Union
from dataclasses import replace

from .data import *


def bit_to_type(bits: int):
    typemap = {
        8: ctypes.c_uint8,
        16: ctypes.c_uint16,
        32: ctypes.c_uint32,
        64: ctypes.c_uint64,
    }
    bits = 1 << (bits - 1).bit_length()
    if bits < 8:
        bits = 8
    return typemap[bits]


def is_pythonable(t: Union[str, TypeBase]) -> bool:
    """
    Checks if a TypeBase or str can be converted to a valid Python ctypes type.
    """
    if isinstance(t, TypeBase):
        name = t.fullname
    else:
        name = t
    if "<" in name or ">" in name or "," in name:
        return False
    return True


def to_python_name(t: Union[str, TypeBase]) -> str:
    """
    Converts a TypeBase or str to a valid Python ctypes name.
    Supports known fixed-width integral and floating-point types.
    """
    if isinstance(t, TypeBase):
        name = t.fullname
    else:
        name = t

    fixed_map = {
        "int8_t": "ctypes.c_int8",
        "uint8_t": "ctypes.c_uint8",
        "int16_t": "ctypes.c_int16",
        "uint16_t": "ctypes.c_uint16",
        "int32_t": "ctypes.c_int32",
        "uint32_t": "ctypes.c_uint32",
        "int64_t": "ctypes.c_int64",
        "uint64_t": "ctypes.c_uint64",
        "int128_t": "ctypes.c_int64 * 2",
        "uint128_t": "ctypes.c_uint64 * 2",
        "float": "ctypes.c_float",
        "double": "ctypes.c_double",
        "long double": "ctypes.c_longdouble",
        "void*": "ctypes.c_void_p",
        "bool": "ctypes.c_bool",
    }

    if name in fixed_map:
        return fixed_map[name]

    # Namespace fallback
    return (
        name.replace("::", "__").replace("<", "_").replace(">", "_").replace("@", "_")
    )


def generate_python_code_from_definitions(
    definitions: List[TypeBase], alignment=None, assert_size=True
) -> str:
    lines = [
        "# fmt: off",
        "# Automatically generated by HIDA",
        "",
        "import ctypes",
        "",
    ]

    for d in definitions:
        if not is_pythonable(d):
            continue
        if isinstance(d, (ClassDefinition, UnionDefinition)):
            typename = "Structure" if isinstance(d, ClassDefinition) else "Union"
            lines.append(
                f"# Python implementation of {d.fullname}, size = {d.size} bytes"
            )
            lines.append(f"class {to_python_name(d)}(ctypes.{typename}):")

            if alignment:
                lines.append(f"    _pack_ = {alignment}")
            elif d.alignment > 0:
                lines.append(f"    _pack_ = {d.alignment}")

            lines.append("    _fields_ = [")

            for f in d.fields:
                tname = to_python_name(f.type)
                dims = "".join(f" * {dim}" for dim in f.elements if dim > 0)
                bit = f", {f.size_in_bits}" if f.bitfield else ""
                lines.append(f"        ('{f.name}', {tname}{dims}{bit}),")

            lines.append("    ]")
            if assert_size:
                lines.append(f"assert ctypes.sizeof({to_python_name(d)}) == {d.size}")
            lines.append("")

        elif isinstance(d, EnumDefinition):
            base = bit_to_type(d.size * 8)
            lines.append(
                f"class {to_python_name(d)}({base.__module__}.{base.__name__}):"
            )
            enums = d.enums
            if len(enums) == 0:
                enums = [EnumName(name="DUMMY", value=0)]
            for e in enums:
                lines.append(f"    {e.name} = {e.value}")

            lines.append("")

        elif isinstance(d, TypedefDefinition):
            lines.append(f"{to_python_name(d)} = {to_python_name(d.type)}")
        elif isinstance(d, ConstantDefinition):
            lines.append(
                f"{to_python_name(d)} = {repr(d.value)}  # type: {to_python_name(d.type)}"
            )
        else:
            raise ValueError(f"Unhandled definition type: {type(d)}")

    return "\n".join(lines)


def write_code_to_file(code: str, filename: str):
    with open(filename, "w") as f:
        f.write(code)


def generate(definitions, filename, assert_size=True, verify=False, verify_size=False):
    code = generate_python_code_from_definitions(definitions, assert_size=assert_size)
    write_code_to_file(code, filename)
    if verify or verify_size:
        spec = importlib.util.spec_from_file_location("generated", filename)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

    if verify_size:
        verify_struct_sizes(
            [
                d
                for d in definitions
                if isinstance(d, (ClassDefinition, UnionDefinition))
            ],
            module,
        )


def verify_struct_sizes(defs, module):
    for d in defs:
        pyclass = getattr(module, to_python_name(d))
        actual = ctypes.sizeof(pyclass)
        expected = d.size
        print(f"Verifying {d.name}: {actual=} vs {expected=}")
        assert actual == expected, f"Size mismatch for {d.name}: {actual} != {expected}"
